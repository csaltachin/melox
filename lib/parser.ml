type ast = Ast.expression
(** Type of an AST node. For now, we only have expression nodes. *)

type t = { tokens : Token.t list; previous : Token.t option }
(** Type of parser. Maintains a list of (wrapped) tokens yet to be consumed, as
    well as the most recently consumed token.

    The functions in the [Parser] module assume that the token list does not end
    with an EOF token, e.g. as generated by [Scanner.scan ~drop_eof:true]. *)

type eof_error = Eof
type parse_error = UnexpectedToken | UnexpectedEof

type parse_result = (t * ast, parse_error) result
(** Result type for parse-consumers. *)

type parse_consumer = t -> parse_result
(** Type of "parse-consumers": operations which take in a parser state and emit
    either a pair (advanced parser state, new AST node) or a parse error. *)

(** Initialize a parser from a list of tokens. The functions in the [Parser]
    module assume that this list does not contain a trailing EOF token, e.g. as
    generated by [Scanner.scan ~drop_eof:true]. *)
let init tokens = { tokens; previous = None }

(** Peek the current, next-to-be-consumed token, i.e. the first element of
    [parser.tokens]. Returns [Error Eof] if the token list is empty. *)
let peek parser =
  match parser.tokens with curr :: _ -> Ok curr | [] -> Error Eof

(** Peek the token immediately after the current token, i.e. the second element
    of [parser.tokens]. Returns [Error Eof] if the token list has less than two
    elements. *)
let peek_next parser =
  match parser.tokens with _ :: next :: _ -> Ok next | _ -> Error Eof

(** Peek the most recently consumed token. Note that this will not be the first
    element of [parser.tokens], but rather the element immediately before it
    (before it was popped from the list). *)
let peek_previous parser = parser.previous

(** Consume one token, and return the new parser state (after advancing by one
    token). Returns [Error Eof] if there were no remaining tokens. *)
let advance parser =
  match parser.tokens with
  | curr :: tail -> Ok { tokens = tail; previous = Some curr }
  | [] -> Error Eof

(** Try to consume a token and return the new parser state. If there were no
    more tokens, return the same parser state.

    This is the same as [advance parser], but mapping [Ok parser'] to [parser']
    and [Error Eof] to [parser]. *)
let advance_ceil parser = Result.value (advance parser) ~default:parser

(** Peek the current token. If the peek succeeds as [Ok token] and
    [matches token.raw] is true, then consume the token, and return the advanced
    parser and [Some token]. Otherwise, return back the same parser state and
    [None]. *)
let advance_if_match (matches : Token.raw_t -> bool) parser =
  match peek parser with
  | Ok token when matches token.raw -> (advance_ceil parser, Some token)
  | _ -> (advance_ceil parser, None)

(** Given a parse-consumer [consumer] and a [matches] function, returns a new
    parse-consumer that (greedily) produces a left-associative, binary AST node,
    whose "leaves" are nodes produced by applications of [consumer]. A token
    [token] is considered an operator iff [matches (token.raw)] evaluates to
    true, and all such tokens are considered with equal precedence.

    In other words, let [pi] be a precedence level, and suppose [token] is an
    operator with precedence [pi] iff [matches (token.raw)] is true. Then
    [consume_binary_left_assoc consumer matches] is a parse-consumer that, given
    a parser state [parser], performs the following:

    (i) Attempt to apply [consumer] on [parser] to produce a new AST node [acc]
    and a parser state [parser'].

    (ii) Peek the current token [op] (if any). If it is an operator token with
    precedence [pi], then
    - consume [op];
    - attempt to apply [consumer] on the resulting parser state, producing an
      AST node [new_node] and a parser state [parser'];
    - replace [acc] with a new binary AST node, with operator token [op], right
      child [new_node], and left child [acc].

    (iii) Return the final AST node [acc] wrapped in [Ok], or forward any parse
    error encountered in any application of [consumer] in steps (i) and (ii).

    In particular, if [consumer] is tail-recursive, then this parse-consumer
    will also be tail-recursive. *)
let consume_binary_left_assoc (consumer : parse_consumer)
    (matches : Token.raw_t -> bool) : parse_consumer =
  let ( let* ) = Result.bind in
  let rec make_aux_list acc parser =
    match advance_if_match matches parser with
    | parser, None -> Ok (parser, List.rev acc)
    | after_match, Some op_token ->
        let* after_node, right_node = consumer after_match in
        let acc' = (op_token, right_node) :: acc in
        make_aux_list acc' after_node
  in
  let tree_of_aux_list first_node aux_list =
    match aux_list with
    | [] -> first_node
    | (first_op, second_node) :: rest ->
        let init =
          Ast.Binary { left = first_node; op = first_op; right = second_node }
        in
        let f acc aux_item =
          let op, right = aux_item in
          Ast.Binary { left = acc; op; right }
        in
        List.fold_left f init rest
  in
  fun parser ->
    let* after_first, first_node = consumer parser in
    let* after_last, aux_list = make_aux_list [] after_first in
    Ok (after_last, tree_of_aux_list first_node aux_list)
